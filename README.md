# nixie  
**Declarative NixOS configuration for a production‑grade server**  

![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/quantinium3/nixie/ci.yml?branch=main&label=CI&logo=github)  
![License](https://img.shields.io/github/license/quantinium3/nixie?color=blue)  
![Nix Version](https://img.shields.io/badge/Nix-2.20%2B-blue?logo=nixos)  
![Flake Version](https://img.shields.io/badge/Flake-unstable-green)  

[Demo (DigitalOcean)](https://cloud.digitalocean.com) • [Issues](https://github.com/quantinium3/nixie/issues) • [Discussions](https://github.com/quantinium3/nixie/discussions)  

---  

## Overview  

`nixie` is a **stand‑alone NixOS flake** that provisions a fully reproducible server on DigitalOcean (or any other machine) using only declarative Nix expressions.  
All system services – from the bootloader to networking, users, packages, and secrets – are defined in a single, version‑controlled repository, making the server **immutable, auditable, and easy to redeploy**.

> **Why use nixie?**  
> * **One‑source‑of‑truth**: the entire host configuration lives in Nix code.  
> * **Zero‑drift**: `nixos-rebuild switch --flake .#nixie` always brings the machine back to the exact state described in the repo.  
> * **Secure secrets**: secrets are stored encrypted with **sops** and automatically injected into the system.  
> * **Portable**: the same flake can target a local VM, a cloud VM, or a physical machine with minimal changes.

Target audience: DevOps engineers, SREs, and hobbyists who want a reproducible, declarative server setup powered by NixOS.

Current version: **v0.1.0** (main branch)

---  

## Features  

| Feature | Description | Status |
|---------|-------------|--------|
| **Declarative system** | Entire OS configuration expressed as Nix modules. | ✅ Stable |
| **Flake‑based** | Uses Nix flakes for reproducible inputs and pinning. | ✅ Stable |
| **DigitalOcean integration** | Pre‑configured `digitalocean.nix` for cloud‑specific settings (droplet size, region, SSH keys). | ✅ Stable |
| **Encrypted secrets** | `secrets.yaml` encrypted with **sops**; secrets are decrypted at build time and injected via `environment.etc`. | ✅ Stable |
| **Custom user management** | `user.nix` creates a non‑root user with sudo, SSH keys, and optional home‑manager integration. | ✅ Stable |
| **NGINX reverse proxy** | Fully‑featured NGINX module with TLS (via Let's Encrypt) and basic site scaffolding. | ✅ Stable |
| **Eris service** | Example custom service (`eris.nix`) showing how to add arbitrary systemd units. | ✅ Stable |
| **GRUB bootloader** | Configurable GRUB for both BIOS and UEFI systems. | ✅ Stable |
| **Disk layout** | `disk-config.nix` defines partitions, LVM, and filesystem layout for fresh installs. | ✅ Stable |
| **Extensible module system** | All modules live under `nixie/modules/` and can be overridden by downstream flakes. | ✅ Stable |
| **CI linting** | GitHub Actions run `nix fmt` and `nix flake check` on every PR. | ✅ Stable |

---  

## Tech Stack  

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Package manager** | **Nix** (≥ 2.20) | Purely functional, reproducible builds |
| **OS** | **NixOS** (unstable channel) | Declarative OS configuration |
| **Flake** | `flake.nix` | Pin dependencies, expose `nixie` host |
| **Secrets** | **sops** + **age** | Encrypt `secrets.yaml` in Git |
| **Cloud provider** | **DigitalOcean** | Example provider; can be swapped |
| **Web server** | **NGINX** | Reverse proxy / static site serving |
| **Bootloader** | **GRUB** | BIOS/UEFI boot management |
| **Version control** | **Git** | Source of truth for configuration |
| **CI** | **GitHub Actions** | Automatic formatting & lint checks |

---  

## Architecture  

```
.
├── flake.nix            # Top‑level flake exposing the `nixie` host
├── flake.lock           # Locked inputs (nixpkgs, sops, etc.)
├── hosts/
│   └── nixie/
│       ├── configuration.nix   # Host‑specific configuration (imports modules)
│       ├── digitalocean.nix    # DO‑specific settings (region, size, SSH keys)
│       ├── disk-config.nix     # Partitioning & LVM layout
│       └── hardware-configuration.nix  # Generated by `nixos-generate-config`
├── nixie/
│   └── modules/
│       ├── default.nix         # Re‑exports all modules
│       ├── eris.nix            # Example custom systemd service
│       ├── grub.nix            # GRUB configuration
│       ├── networking.nix      # Network interfaces, firewall, DHCP
│       ├── nginx.nix           # NGINX site & TLS config
│       ├── packages.nix        # Extra packages to install globally
│       ├── user.nix            # User creation, SSH keys, sudo
│       └── xunback.nix         # Placeholder for backup service
└── secrets/
    └── secrets.yaml            # Encrypted secret store (managed by sops)
```

* **Flake entry point** – `flake.nix` defines the `nixie` host and exposes a `nixosConfigurations.nixie` attribute.  
* **Host configuration** – `hosts/nixie/configuration.nix` imports the shared modules and adds host‑specific overrides (e.g., DigitalOcean droplet size).  
* **Modules** – Each module encapsulates a logical piece of the system (networking, users, services). They can be overridden by downstream flakes via the standard NixOS module system.  
* **Secrets** – `secrets.yaml` is encrypted with **sops**; the flake reads it via `builtins.readFile` after decryption, exposing the values as Nix attributes (e.g., `secrets.myApiKey`).  

---  

## Getting Started  

### Prerequisites  

| Tool | Minimum version |
|------|-----------------|
| **Nix** | 2.20+ (installed with `nix --experimental-features 'flakes nix-command'`) |
| **Git** | any recent version |
| **sops** | 3.7+ (for secret decryption) |
| **age** | 1.0+ (used by sops) |
| **SSH key** | Added to your DigitalOcean account (or any target host) |
| **DigitalOcean account** (optional) | For the provided cloud configuration |

> **Note** – The flake works on any Linux machine that can run NixOS; DigitalOcean is only an example.

### Installation  

1. **Clone the repository**  

   ```bash
   git clone https://github.com/quantinium3/nixie.git
   cd nixie
   ```

2. **Enable flakes (if not already)**  

   ```bash
   mkdir -p ~/.config/nix
   cat <<EOF > ~/.config/nix/nix.conf
   experimental-features = nix-command flakes
   EOF
   ```

3. **Install `sops` and `age`** (required for secret handling)  

   ```bash
   nix profile install nixpkgs#sops nixpkgs#age
   ```

4. **Decrypt the secrets (optional – only needed if you want to use them locally)**  

   ```bash
   # The repository contains an encrypted secrets.yaml.
   # Decrypt it into the Nix store (the result is a temporary file).
   sops -d secrets/secrets.yaml > secrets/secrets.decrypted.yaml
   ```

   > **Tip** – If you are using a CI pipeline, configure `SOPS_AGE_KEY` or `SOPS_GPG_EXEC` as described in the sops docs.

5. **Build the NixOS system**  

   ```bash
   # Build the system configuration for the `nixie` host
   nix build .#nixosConfigurations.nixie.config.system.build.toplevel
   ```

   The command will output a symlink `result` pointing to the generated system closure.

6. **Deploy to a target machine**  

   *If you are provisioning a fresh DigitalOcean droplet:*  

   ```bash
   # Replace <IP> with the droplet's public IP
   nix copy --to ssh://root@<IP> ./result
   ssh root@<IP> ./result/bin/switch-to-configuration switch
   ```

   *If you are installing on a local VM:*  

   ```bash
   # Boot the VM with the generated initrd
   sudo nixos-rebuild switch --flake .#nixie
   ```

### Verification  

```bash
# Verify that the system reports the expected hostname and services
hostnamectl
systemctl status nginx
```

You should see NGINX running on port 80 (or 443 if TLS is enabled) and the custom `eris` service listed as active.

---  

## Usage  

### Basic commands  

| Command | Description |
|---------|-------------|
| `nixos-rebuild switch --flake .#nixie` | Apply the configuration to the current machine (imperative). |
| `nixos-rebuild test --flake .#nixie` | Build and test the config without persisting changes. |
| `nix develop` | Drop into a development shell with all flake dependencies (useful for editing modules). |
| `nix fmt` | Auto‑format all Nix files (`*.nix`). |
| `nix flake check` | Run static checks (e.g., `nixpkgs-fmt`, dead‑code detection). |

### Adding a new package  

Edit `nixie/modules/packages.nix` and add the desired package to the `environment.systemPackages` list, e.g.:

```nix
{ pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    vim
    htop
    # New package
    git
  ];
}
```

Then run `nixos-rebuild switch --flake .#nixie`.

### Adding a custom systemd service  

1. Create a new module file, e.g., `nixie/modules/myservice.nix`.  
2. Export a `systemd.services.myservice` attribute set.  
3. Import the module in `hosts/nixie/configuration.nix` (or add it to `modules/default.nix`).  

Example (`myservice.nix`):

```nix
{ config, lib, pkgs, ... }:
{
  systemd.services.myservice = {
    description = "My custom background worker";
    after = [ "network.target" ];
    wantedBy = [ "multi-user.target" ];
    serviceConfig = {
      ExecStart = "${pkgs.mybinary}/bin/mybinary --serve";
      Restart = "on-failure";
    };
  };
}
```

### Managing secrets  

All secrets are available under the `secrets` attribute after decryption:

```nix
# Example usage in a module
{ config, secrets, ... }:
{
  services.nginx = {
    enable = true;
    # Use a TLS key stored in secrets.yaml
    sslCertificate = "/run/secrets/nginx.crt";
    sslCertificateKey = "/run/secrets/nginx.key";
  };
}
```

Place the secret files in `secrets/secrets.yaml` like:

```yaml
nginx:
  crt: |
    -----BEGIN CERTIFICATE-----
    …
    -----END CERTIFICATE-----
  key: |
    -----BEGIN PRIVATE KEY-----
    …
    -----END PRIVATE KEY-----
```

Commit only the **encrypted** version; the plain text is never stored in Git.

---  

## Development  

### Setting up a development environment  

```bash
# Enter a shell with all flake inputs (nixpkgs, sops, etc.)
nix develop
```

The shell provides `nixfmt`, `nixpkgs-fmt`, `sops`, `age`, and the `nixos-rebuild` command.

### Running tests  

The repository currently contains a minimal test suite that checks that the flake evaluates and that the generated system configuration contains expected attributes.

```bash
nix flake check
```

Add new tests by extending `flake.nix` with a `checks` attribute that uses `nixpkgs.lib.runCommand` or `nixosTests`.

### Code style  

* Use **`nixfmt`** (`nix fmt`) before committing.  
* Keep each module self‑contained and document exported options with comments.  
* Prefer `lib.mkOption` and `lib.mkEnableOption` for user‑configurable values.

### Debugging tips  

* `journalctl -u <service>` – view logs for a systemd unit.  
* `nixos-option <option>` – inspect the final value of a NixOS option.  
* `nix repl` – interactive REPL for experimenting with Nix expressions.

---  

## Deployment  

### Production deployment (DigitalOcean)  

1. **Create a droplet** (Ubuntu or any distro – the OS will be replaced).  
2. **Add your SSH public key** to the droplet.  
3. **Run the deployment script** (example below):

   ```bash
   # Replace placeholders
   export DO_TOKEN="your_digitalocean_api_token"
   export HOST_IP="your_droplet_ip"

   # Copy the built system to the droplet
   nix copy --to ssh://root@$HOST_IP ./result

   # Switch to the new configuration
   ssh root@$HOST_IP ./result/bin/switch-to-configuration switch
   ```

4. **Verify** that services are up and that the firewall (if enabled) allows the expected ports.

### Docker / container usage  

The flake can also be built as a Docker image:

```bash
nix build .#dockerImage
docker load < result
docker run -d -p 80:80 -p 443:443 nixie:latest
```

> **Note** – The Docker image contains a full NixOS system; it is primarily useful for testing or CI pipelines.

### Performance considerations  

* **SSD vs HDD** – The `disk-config.nix` assumes an SSD layout (ext4 on LVM). Adjust `fileSystems` if you use HDDs.  
* **Swap** – A 2 GiB swap file is created by default; tune it in `disk-config.nix` for memory‑intensive workloads.  
* **Firewall** – The `networking.nix` module enables `ufw` with a default deny‑incoming policy; open only required ports.

---  

## Contributing  

We welcome contributions! Please follow these steps:

1. **Fork the repository** and create a feature branch.  
2. **Run `nix fmt`** and ensure `nix flake check` passes.  
3. **Write tests** (if you add new modules or options).  
4. **Open a Pull Request** with a clear description of the change.  

### Development workflow  

| Step | Command |
|------|---------|
| Create a branch | `git checkout -b feature/my‑new‑module` |
| Keep the flake up‑to‑date | `nix flake update` |
| Run CI locally | `nix flake check` |
| Submit PR | Push to your fork and open a PR on GitHub |

### Code review guidelines  

* Verify that the module follows the existing naming conventions (`<name>.nix`).  
* Ensure all new options have documentation comments.  
* Check that secrets are **never** added in plain text.  
* Confirm that the change does not break the default host (`nixie`).

---  

## License & Credits  

**License**: MIT License – see the [LICENSE](https://github.com/quantinium3/nixie/blob/main/LICENSE) file.  

**Authors & Maintainers**  

* **Quantinium3** – <https://github.com/quantinium3>  

**Acknowledgments**  

* The NixOS community for the excellent documentation and modules.  
* **sops** – for seamless secret encryption.  
* **DigitalOcean** – for providing a simple cloud platform for testing.  

---  

*Happy Nixing!*  